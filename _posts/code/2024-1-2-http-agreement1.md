---
layout:     post
title:      "Http概述"
date:       2024-1-2
author:     "Mtz"
catalog: true
tags:
    - 网络
---



# Http简介

#### Http概述

* **HTTP 是一种能够获取如 HTML 这样的网络资源的** [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)(通讯协议)。请求通常是由像==浏览器这样的接受方发起的==。
* 客户端和服务端通过交换各自的消息进行交互。由像浏览器这样的客户端发出的消息叫做*请求*（request），被服务端响应的消息叫做*响应*（response）。

####  客户端：user-agent

* user-agent就是任何能够为用户发起行为的工具，一般浏览器来扮演。

* 要展现一个网页，浏览器首先发送一个请求来获取页面的HTML文档，解析文档资源发送请求，获取可执行脚本或CSS样式，渲染页面，浏览器资源整合，展现一个完整的文档。

* 浏览器负责发送HTTP请求，并进一步解析HTTP返回的信息。

  

  #### Web服务端

  一般来说，server 有两重意思

  1. 有时候 server 表示硬件，也就是一台机器。它还有另一个名字：「主机」。
  2. 更多时候，server 表示软件程序，这种程序主要用来对外提供某些服务，比如邮件服务、FTP 服务、数据库服务、网页服务等。

  作为开发者，我们说 server 的时候，一般指的后者，也就是一==个 24 小时运行的软件程序==。

  一台主机上面可以运行多个这样的程序。

  

  #### 代理（Proxy）

在HTTP（超文本传输协议）中，代理（Proxy）是一种==充当客户端和服务器之间中间人的服务器==。当客户端发送HTTP请求时，代理接收请求并转发给目标服务器，然后将响应返回给客户端。代理服务器在客户端和服务器之间起到了中转的作用。

代理服务器可以用于多种目的，包括以下几个方面：

1. 缓存：代理服务器可以缓存之前请求过的资源。当客户端再次请求相同的资源时，代理可以直接返回缓存的响应，从而提高响应速度和减轻服务器负载。
2. 过滤和防火墙：代理服务器可以用于过滤请求和响应，以实现对特定内容或恶意代码的阻止。它们还可以用于实施网络安全策略，例如限制对特定网站的访问。
3. 匿名性：代理服务器可以隐藏客户端的真实IP地址，从而为用户提供匿名性和隐私保护。这对于绕过地理限制或访问受限制的内容很有用。
4. 负载均衡：代理服务器可以将请求分发到多个后端服务器，实现负载均衡，从而提高系统的性能和可扩展性。

#### Http三点注意事项

* HTTP是无连接：含义是限制==每次连接只处理一个请求==，服务器处理完客户的请求，并收到客户的应答后，即断开连接，节省传输时间。

* HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送，==客户端以及服务器指定使用核实的MIMT-type内容类型==。

* HTTP是无状态：

  1. ==每个HTTP请求都是独立的==，服务器不会在多个请求之间保持任何关于客户端的状态信息。这意味着每个HTTP请求都是独立且相互无关的。
  2. 当客户端发送HTTP请求到服务器时，服务器会处理该请求并返回相应的响应。==完成响应后，服务器不会保留与该特定请求相关的任何信息==。下一次客户端发送请求时，服务器将不会知道先前的请求和响应，也不会将其与当前请求相关联。
  3. 然而，由于许多应用程序需要在多个请求之间共享和保持状态信息（如用户登录状态、购物车内容等），HTTP提供了机制来实现状态管理。其==中最常用的机制是使用Cookie和Session==。通过在客户端和服务器之间传递标识符或令牌，可以在一系列请求中跟踪和管理状态信息。

------



# Http消息结构

HTTTP消息是由两种类型的消息组成：==请求消息和响应消息==，每种消息都有不同的结构。

##### 客户端发送请求消息

客户端发送一个HTTP请求到服务器的请求消息格式：

1. 请求行（request line）
2. 请求头部（header）
3. 空行
4. 请求数据

##### 服务器响应消息

响应消息结构：

- 状态行：包含HTTP版本、状态码和对应的状态消息。
- 响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。
- 空行：空行用于分隔响应头部和响应体。
- 响应体：响应的实际内容，例如HTML文档、JSON数据等。

![响应结构](https://telegraph-image-a8w.pages.dev/file/30c5a3342d11cd2ae5fe6.png)

------



# HTTP请求方法

HTTP定于了多种请求方法，指示==客户端对服务器上的资源执行不同的操作==。

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 获取资源。使用GET方法，==客户端请求服务器发送指定资源的副本==。GET请求应该是安全和幂等的，即不应该对服务器状态产生任何影响。 |
| POST    | 提交数据。使用POST方法==，客户端向服务器提交数据，例如提交表单数据或上传文件==。POST请求可能会对服务器状态进行更改，例如创建新资源或处理数据。 |
| PUT     | 更新资源。使用PUT方法，客户端向服务器发送数据以替换指定资源。PUT请求用于完全替换目标资源，而不是部分修改。 |
| DELETE  | 删除资源。使用DELETE方法，客户端请求服务器删除指定资源。     |
| PATCH   | 部分更新资源。使用PATCH方法，客户端向服务器发送数据以部分更新指定资源，只修改资源的一部分而不是替换整个资源。 |
| HEAD    | 获取资源的元数据。使用HEAD方法，==客户端请求服务器返回与GET请求相同的响应头部信息，但没有响应体==。这对于获取资源的元数据，如大小、类型或修改日期等非常有用。 |
| OPTIONS | 获取支持的方法和资源的通信选项。使用OPTIONS方法，客户端请求服务器==返回有关服务器支持的方法和资源的信息==。这对于检查服务器支持哪些方法或跨域资源共享（CORS）的预检请求非常有用。 |

# HTTP响应头消息

HTTP响应消息中的头部（Header）,字段提供了关于响应的元数据信息，头部字段以键值对的形式存在，位于响应消息的起始部分。

| 键                          | 值                                                           |
| --------------------------- | ------------------------------------------------------------ |
| Content-Type                | 指定响应体的媒体类型（MIME类型），如"text/html"表示HTML文档，"application/json"表示JSON数据。 |
| Content-Length              | 指定响应体的长度，以字节为单位。                             |
| Date                        | 指定响应生成的日期和时间。                                   |
| Server                      | 指定服务器软件的名称和版本。                                 |
| Set-Cookie                  | 在响应中设置一个或多个Cookie。                               |
| Cache-Control               | 指定响应的缓存控制选项，如缓存的有效期、是否允许缓存等。     |
| Expires                     | 指定响应的过期日期和时间，告诉客户端可以使用缓存的副本直到该时间。 |
| Last-Modified               | 指定资源的最后修改日期和时间。                               |
| Location                    | 指定重定向的目标URL。                                        |
| ETag                        | 指定资源的实体标签，用于验证缓存的副本是否仍然有效。         |
| Access-Control-Allow-Origin | 指定允许访问响应的资源的域或来源，用于跨域资源共享（CORS）。 |
| X-Powered-By                | 指定响应的后端服务器框架或技术                               |

Location ： 重定向

# HTTP状态码

HTTP状态码是服务器在响应请求时返回的三位数字代码，用于==表示请求的处理结果和状态==。

##### HTTP状态码分类

1. 1xx（信息性状态码）：表示请求已被接收，需要进一步处理。
   - 100 Continue：服务器已收到请求的一部分，客户端应继续发送剩余部分。
   - 101 Switching Protocols：服务器要求客户端切换协议。
2. 2xx（成功状态码）：表示请求已成功被服务器接收、理解和处理。
   - 200 OK：请求成功，返回所请求的数据。
   - 201 Created：请求成功，服务器已创建新的资源。
   - 204 No Content：请求成功，但响应没有返回任何内容。
3. 3xx（重定向状态码）：表示需要进一步操作以完成请求。
   - 301 Moved Permanently：被请求的资源已永久移动到新位置。
   - 302 Found：被请求的资源临时移动到新位置。
   - 304 Not Modified：资源未修改，客户端可以使用缓存的版本。
4. 4xx（客户端错误状态码）：表示客户端发出的请求有错误。
   - 400 Bad Request：请求有语法错误，服务器无法理解。
   - 401 Unauthorized：请求要求身份验证。
   - 404 Not Found：请求的资源不存在。
5. 5xx（服务器错误状态码）：表示服务器在处理请求时遇到错误。
   - 500 Internal Server Error：服务器遇到了意外错误。
   - 503 Service Unavailable：服务器当前无法处理请求，通常是由于过载或维护。

# HTTP ContentType

ContantType对照表 ：[HTTP content-type | 菜鸟教程 (runoob.com)](https://www.runoob.com/http/http-content-type.html)

HTTP的Content-Type是==指在HTTP请求或响应中传输的实体的媒体类型==（Media Type）,也称为MIME类型。

Content-Typt由两部分组成：类型和子类型，以及可选的参数。



Content-Type的常见类型和子类型包括：

| 类型             | 解释         |
| ---------------- | ------------ |
| text/plain       | 纯文本类型   |
| text/html        | HTML文档类型 |
| application/json | JSON数据类型 |
| application/xml  | XML数据类型  |
| image/jpeg       | JPEG图像类型 |
| image/png        | PNG图像类型  |
| audio/mpeg       | MPEG音频类型 |
| video/mp4        | MP4视频类型  |
| application/pdf  | PDF文档类型  |

除了类型和子类型之外，Content-Type还可以包含一些可选的参数，用于提供更多的信息或指示如何处理实体数据。例如，charset参数指定了字符编码，如UTF-8或ISO-8859-1。

示例：

- Content-Type: text/html; charset=UTF-8
- Content-Type: application/json

客户端在发送请求时，通常会设置适当的Content-Type，以==指定请求体中的数据类型==。服务器在返回响应时，会使用Content-Type来告知客户端响应的数据类型。这样客户端就可以正确解析和处理返回的数据。

![Contentype](https://telegraph-image-a8w.pages.dev/file/4e6e59b240621ca375d54.png)

------

# HTTP报文

HTTP报文是在HTTP协议中==用于在客户端和服务器之间传输数据的格式化信息==。它由请求报文和响应报文两种类型组成。

1. 请求报文（Request Message）：由客户端发送给服务器，用于请求特定资源或执行特定操作。请求报文包括以下部分：
   - 请求行（Request Line）：包含HTTP方法、目标URL和HTTP协议版本。
   - 请求头部（Request Headers）：包含关于请求的元数据信息，如User-Agent、Accept、Content-Type等。
   - 请求主体（Request Body）：可选的，用于在POST或PUT请求中传输数据。
2. 响应报文（Response Message）：由服务器发送给客户端，用于回应客户端的请求。响应报文包括以下部分：
   - 状态行（Status Line）：包含HTTP协议版本、状态码和状态消息。
   - 响应头部（Response Headers）：包含关于响应的元数据信息，如Content-Type、Content-Length、Cache-Control等。
   - 响应主体（Response Body）：包含实际的响应数据，如HTML文档、JSON数据等。

示例请求报文

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

示例响应报文

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<!DOCTYPE html>
<html>
<head>
    <title>Example Page</title>
</head>
<body>
    <h1>Hello, world!</h1>
</body>
</html>
```

------

# HTTP的Cookie & Session

## Cookie

* HTTP cookie（简称Cookie）是一种用于在==客户端和服务器之间传递和存储数据的小型文本文件==。

* 它由==服务器通过HTTP响应头部中的Set-Cookie字段==发送给客户端，并由客户端在后续的请求中通过Cookie请求头部发送回服务器。

* Cookie通常用于在无状态的HTTP协议中跟踪和识别特定用户的状态信息，以实现会话管理、用户认证、个性化设置等功能。

* 当服务器接收到包含Cookie的请求时，它可以根据Cookie中的数据来识别用户，并根据需要进行相应的操作。

一个Cookie通常包含以下几个属性：

1. 名称（Name）：用于标识Cookie的名称。
2. 值（Value）：存储在Cookie中的数据。
3. 域（Domain）：指定Cookie可以被发送到哪个域名。
4. 路径（Path）：指定Cookie适用的URL路径。
5. 过期时间（Expires/Max-Age）：指定Cookie的有效期限。
6. 安全标志（Secure）：指示Cookie是否仅通过安全（HTTPS）连接发送。
7. HttpOnly标志：指示Cookie是否只能通过HTTP协议访问，而不能通过脚本（如JavaScript）访问。

* 当服务器发送一个Set-Cookie头部时，客户端会将Cookie保存起来，并在后续的请求中自动发送回服务器。服务器可以通过读取请求中的Cookie来获取相应的数据，并根据需要进行处理。

* 需要注意的是，Cookie是存储在客户端的，因此可以被客户端修改或删除。服务器应该对接收到的Cookie进行验证和处理，以确保数据的安全性和正确性。另外，由于Cookie存储在客户端，每个域名下的Cookie是相互隔离的，一个域名下设置的Cookie无法被其他域名访问。

* 总结而言，HTTP Cookie是一种用于在客==户端和服务器之间传递和存储数据的机制==。它通过在HTTP请求和响应中传递特定的文本文件来跟踪和识别用户状态，并实现会话管理、用户认证等功能。Cookie在实际的Web开发中被广泛应用，但也需要注意对Cookie的安全性和正确性进行适当的处理和验证。

## Session

* HTTP会话通过==在客户端和服务器之间传递会话标识符（Session ID）来跟踪和识别特定用户的状态==。当用户首次与服务器建立连接时，**服务器会创建一个唯一的会话标识符**，并将其发送给客户端。**客户端通常将会话标识符存储在Cookie中**，随后的请求会自动携带该Cookie信息。服务器接收到请求时，可以通过会话标识符来查找对应的会话数据，并维护用户的状态。

* 会话数据可以包含与用户相关的信息，如登录状态、用户首选项、购物车内容等。服务器可以在会话中存储这些数据，以便在用户的后续请求中使用。会话数据可以存储在服务器内存中、数据库中或其他持久化存储中，具体取决于实现的方式和需求。

* 通过会话，服务器可以在多个请求之间共享用户的状态，实现用户认证、权限管理、购物车功能等。会话的生命周期可以通过超时时间、用户注销或会话失效等条件来控制。

* 需要注意的是，HTTP会话是在应用层实现的机制，并不是HTTP协议本身的一部分。具体的会话管理方式可以通过编程语言、框架或库来实现，如使用服务器端的Session对象或第三方的会话管理工具。

* 总结而言，HTTP会话是一种通过会话标识符在无状态的HTTP协议上维护用户状态的机制。它通过在请求和响应中传递会话标识符来识别用户，并使用会话数据来跟踪和管理用户的状态。会话使得服务器可以在多个请求之间保持用户的状态，并实现一系列功能和操作。

## 应用场景

当用户访问一个网站时，会话（session）和Cookie常常被同时使用以提供更好的用户体验和功能。以下是一些会话和Cookie的应用示例：

1. 用户登录认证：
   - 用户输入用户名和密码登录网站。
   - 服务器验证用户的凭据，并创建一个唯一的会话标识符（Session ID）。
   - 服务器将Session ID存储在服务器端的会话数据中，并将其发送给客户端的Cookie中。
   - 客户端在后续的请求中通过Cookie发送Session ID给服务器。
   - 服务器根据Session ID识别用户，并保持用户的登录状态。
2. 购物车功能：
   - 用户在网站上选择商品并将其添加到购物车中。
   - 服务器创建一个唯一的会话标识符，并将其存储在购物车的会话数据中。
   - 服务器将Session ID发送给客户端的Cookie中。
   - 客户端在后续的请求中通过Cookie发送Session ID给服务器。
   - 服务器根据Session ID识别用户，并恢复用户的购物车内容。
3. 个性化设置：
   - 用户在网站上设置个人偏好，如语言、主题等。
   - 服务器将个人偏好存储在与用户相关联的会话数据中。
   - 服务器将Session ID发送给客户端的Cookie中。
   - 客户端在后续的请求中通过Cookie发送Session ID给服务器。
   - 服务器根据Session ID识别用户，并根据会话数据提供个性化的网站内容。
4. 记住我功能：
   - 用户选择“记住我”选项，以在下次访问时保持登录状态。
   - 服务器在用户登录成功后，创建一个持久性的Cookie，并将其发送给客户端。
   - 客户端保存持久性Cookie，并在下次访问时发送给服务器。
   - 服务器根据持久性Cookie识别用户，并恢复用户的登录状态。

这些示例展示了会话和Cookie的常见应用。会话用于跟踪用户的状态和提供持久化存储，而Cookie用于在客户端和服务器之间传递会话标识符和其他数据。这种结合使用可以实现个性化功能、购物车管理、用户认证等多种功能，提升用户体验和网站的交互性。











