---
layout:     post
title:      "JavaIO流详解"
date:       2024-2-27
author:     "Mtz"
catalog: true
tags:
    - Java
    - Java项目组件文档
---

# IO流概述

1. ## 什么是IO流？

   * I:Input
   * O:Output
   * 通过IO可以完成硬盘文件的读和写

2. ## IO流的分类

   2-1:按照流的方向进行分类

   * 以内存为参照物
     * 往内存中去，叫做输入（Input），或者叫做读(Read)
     * 往内存中出来，叫做输出（Output）,或者叫做写(Write)

   2-2：按照读取数据方式不同进行分类

   * 按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个进制位

   * 这种流是万能的，什么类型的文件都可以读取，包括：文本文件，图片，声音文件，视频文件等。

   * 字节读取

     * 假设文件file1.txt，采用字节流的话是这样读的：
       a中国bc张三fe
       第一次读：一个字节，正好读到’a’
       第二次读：一个字节，正好读到’中’字符的一半。
       第三次读：一个字节，正好读到’中’字符的另外一半。

   * 按照 **`字符`** 的方式读取数据的，一次读取一个字符.

     * 假设文件file1.txt，采用字符流的话是这样读的：
       a中国bc张三fe
       第一次读：'a’字符（'a’字符在windows系统中占用1个字节。）
       第二次读：'中’字符（'中’字符在windows系统中占用2个字节。）

     * 这种流是为了方便读取 **`普通文本文件`** 而存在的，这种流不能读取：图片、声音、视频等文件。只能读取 **`纯文本文件`**，连word文件都无法读取。

     * 纯文本文件，不单单是.txt文件，还包括 **.java、.ini、.py** 。总之只要 **`能用记事本打开`** 的文件都是普通文本文件。

       

   * 流的分类

     * **`输入流、输出流`**
     * **`字节流、字符流`**

3. ## IO流四大家族首领

* 字节流
  * java.io.**InputStream** 字节输入流
  * java.io.**OutputStream** 字节输出流
* 字符流
  * java.io.**Reader** 字符输入流
  * java.io.**Writer** 字符输出流
* 注意：

1. 四大家族的首领都是抽象类。(abstract class)
2.  所有的流都实现了：
   java.io.Closeable接口，都是可关闭的，都有 close() 方法。
   流是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。
3. 所有的 输出流 都实现了：
   java.io.Flushable接口，都是可刷新的，都有 flush() 方法。
   养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下。这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道！）刷新的作用就是清空管道。
   ps：如果没有flush()可能会导致丢失数据。

在java中只要“类名”以 Stream 结尾的都是字节流。以“ Reader/Writer ”结尾的都是字符流。



4. ## Java要掌握的流（16个）

   * 文件专属
     * java.io.FileInputStream（掌握）
     * java.io.FileOutputStream（掌握）
     * java.io.FileReader
     * java.io.FileWriter
   * 转换流（将字节转成字符流）
     * java.io.InputStreamReader
     * java.io.OutputStreamWriter
   * 缓冲流专属
     * java.io.BufferedReader
     * java.io.BufferedWriter
     * java.io.BufferedInputStream
     * java.io.BufferedOutputStream
   * 数据流专属
     * java.io.DataInputStream
     * java.io.DataOutputStream
   * 标准输出流
     * java.io.PrintWriter
     * java.io.PrintStream（掌握）
   * 对象专属流
     * java.io.ObjectInputStream（掌握）
     * java.io.ObjectOutputStream（掌握）
   * File文件类
     * java.io.File
   * 补充：Windows/Linux小知识点
     * Windows：`D:\Soft\QQ\Plugin`
       Linux：   `D:/Soft/QQ/Plugin`
     *  Windows各个文件之间分隔符为：” **\** “；Linux各个文件之间分割符为：” **/** “
   *  IDEA默认的当前路径是？
     * 工程Project的**根**就是IDEA的默认当前路径

5. ## java.io.FileInputStream

* 字符输入流读取数据

```java
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("src/main/resources/test");
            // 开始读，采用byte数组，一次读取多个字节。最多读取“数组.length”个字节。
            byte[] bytes = new byte[3];// 准备一个4个长度的byte数组，一次最多读取4个字节。
            int readCount = 0;
            // 这个方法的返回值是：读取到的字节数量。（不是字节本身）;1个字节都没有读取到返回-1(文件读到末尾)
            while((readCount = fis.read(bytes)) != -1) {
                // 不应该全部都转换，应该是读取了多少个字节，转换多少个。
                System.out.print(new String(bytes, 0, readCount));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 在finally语句块当中确保流一定关闭。
            if (fis != null) {// 避免空指针异常！
                // 关闭流的前提是：流不是空。流是null的时候没必要关闭。
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

```java
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("src/main/resources/test");
            System.out.println("总字节数量：" + fis.available());
            // 读1个字节
            //int readByte = fis.read();
            // 还剩下可以读的字节数量是：5
            //System.out.println("剩下多少个字节没有读：" + fis.available());
            // 这个方法有什么用？
            byte[] bytes = new byte[fis.available()]; // 这种方式不太适合太大的文件，因为byte[]数组不能太大。
            // 不需要循环了。
            // 直接读一次就行了。
            int readCount = fis.read(bytes); // 6
            System.out.println(new String(bytes)); // abcdef

            // skip跳过几个字节不读取，这个方法也可能以后会用！
            fis.skip(3);
            System.out.println(fis.read()); //100

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

6. ## java.io.FileOutputStream

   * 字符输出流写入数据

   ```java
       public static void main(String[] args) {
           FileOutputStream fos = null;
           try {
               // myfile文件不存在的时候会自动新建！
               // 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。
               //fos = new FileOutputStream("myfile");
   
               // 以追加的方式在文件末尾写入。不会清空原文件内容。
               fos = new FileOutputStream("src/main/resources/test", true);
               // 开始写。
               byte[] bytes = {97, 98, 99, 100};
               // 将byte数组全部写出！
               fos.write(bytes); // abcd
               // 将byte数组的一部分写出！
               fos.write(bytes, 0, 2); // 再写出ab
   
               // 字符串
               String s = "我是一个中国人，我骄傲！！！";
               // 将字符串转换成byte数组。
               byte[] bs = s.getBytes();
               // 写
               fos.write(bs);
   
               // 写完之后，最后一定要刷新
               fos.flush();
           } catch (FileNotFoundException e) {
               e.printStackTrace();
           } catch (IOException e) {
               e.printStackTrace();
           } finally {
               if (fos != null) {
                   try {
                       fos.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
           }
       }
   ```

   

7. ## java.io.FileReader（读取纯文本文件）

```java
    public static void main(String[] args) {
        FileReader reader = null;
        try {
            // 创建文件字符输入流
            reader = new FileReader("src/main/resources/test");

            // 开始读
            char[] chars = new char[3]; // 一次读取4个字符
            int readCount = 0;
            while((readCount = reader.read(chars)) != -1) {
                System.out.print(new String(chars,0,readCount));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

8. ## java.io.FileWriter

```java
    public static void main(String[] args) {
        FileWriter out = null;
        try {
            // 创建文件字符输出流对象
            //out = new FileWriter("file");
            out = new FileWriter("src/main/resources/test", true);

            // 开始写。
            char[] chars = {'我','是','中','国','人'};
            out.write(chars);
            out.write(chars, 2, 3);

            out.write("我是一名java软件工程师！");
            // 写出一个换行符。
            out.write("\n");
            out.write("hello world!");

            // 刷新
            out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

9. ##  java.io.BufferedReader、java.io.InputStreamReader

BufferedReader带有缓冲区的字符输入流。使用这个流的时候不需要自定义char数组，或者说不需要自定义byte数组。自带缓冲。

InputStreamReader字节输入流转字符输入流

```java
    public static void main(String[] args) throws Exception{

        FileReader reader = new FileReader("src/main/resources/test");
        // 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。
        // 外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流。
        // 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流/处理流。
        BufferedReader br = new BufferedReader(reader);

        // br.readLine()方法读取一个文本行，但不带换行符。
        String s = null;
        while((s = br.readLine()) != null){
            System.out.print(s);
        }

        // 关闭流
        // 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码。）
        br.close();
    }
```



**转换流：InputStreamReader**

```java
    public static void main(String[] args) throws Exception{

        /*// 字节流
        FileInputStream in = new FileInputStream("Copy02.java");

        // 通过转换流转换（InputStreamReader将字节流转换成字符流。）
        // in是节点流。reader是包装流。
        InputStreamReader reader = new InputStreamReader(in);

        // 这个构造方法只能传一个字符流。不能传字节流。
        // reader是节点流。br是包装流。
        BufferedReader br = new BufferedReader(reader);*/

        // 合并
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/resources/test")));

        String line = null;
        while((line = br.readLine()) != null){
            System.out.println(line);
        }

        // 关闭最外层
        br.close();
    }
```

10. ##  java.io.BufferedWriter、 java.io.OutputStreamWriter

**BufferedWriter：带有缓冲的字符输出流。
OutputStreamWriter：字节输出流转字符输出流**

```java
    public static void main(String[] args) throws Exception{
        // 带有缓冲区的字符输出流
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("src/main/resources/test", true)));
        // 开始写。
        out.write("hello world!");
        out.write("\n");
        out.write("hello kitty!");
        // 刷新
        out.flush();
        // 关闭最外层
        out.close();
    }
```

11. ## java.io.DataInputStream

DataInputStream:数据字节输入流。

DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。

**读的顺序需要和写的顺序一致。才可以正常取出数据。**。

```java
    public static void main(String[] args) throws Exception{
        DataInputStream dis = new DataInputStream(new FileInputStream("src/main/resources/test"));
        // 开始读
        byte b = dis.readByte();
        short s = dis.readShort();
        int i = dis.readInt();
        long l = dis.readLong();
        float f = dis.readFloat();
        double d = dis.readDouble();
        boolean sex = dis.readBoolean();
        char c = dis.readChar();

        System.out.println(b);
        System.out.println(s);
        System.out.println(i + 1000);
        System.out.println(l);
        System.out.println(f);
        System.out.println(d);
        System.out.println(sex);
        System.out.println(c);

        dis.close();
    }
```

12. ##  java.io.DataOutputStream

java.io.DataOutputStream：数据字节输出流。

这个流可以将 **`数据连同数据的类型`** 一并写入文件。

注意：**这个文件不是普通文本文档**。（这个文件使用记事本打不开。）

```java
    public static void main(String[] args) throws Exception{
        // 创建数据专属的字节输出流
        DataOutputStream dos = new DataOutputStream(new FileOutputStream("src/main/resources/test"));
        // 写数据
        byte b = 100;
        short s = 200;
        int i = 300;
        long l = 400L;
        float f = 3.0F;
        double d = 3.14;
        boolean sex = false;
        char c = 'a';
        // 写
        dos.writeByte(b); // 把数据以及数据的类型一并写入到文件当中。
        dos.writeShort(s);
        dos.writeInt(i);
        dos.writeLong(l);
        dos.writeFloat(f);
        dos.writeDouble(d);
        dos.writeBoolean(sex);
        dos.writeChar(c);

        // 刷新
        dos.flush();
        // 关闭最外层
        dos.close();
    }
```

14. ## java.io.PrintStream

java.io.PrintStream：标准的字节输出流。默认输出到控制台。

```java
    public static void main(String[] args) throws Exception{
        // 可以改变标准输出流的输出方向吗？ 可以// 标准输出流不再指向控制台，指向“log”文件。
        PrintStream printStream = new PrintStream(new FileOutputStream("src/main/resources/test"));
        // 修改输出方向，将输出方向修改到"log"文件。
        System.setOut(printStream);// 修改输出方向
        // 再输出
        System.out.println("hello world");
        System.out.println("hello kitty");
        System.out.println("hello zhangsan");
    }

```

15. ### 学习对象流前言

1、java.io.NotSerializableException: Student对象不支持序列化！！！！

2、参与**序列化**和**反序列化**的对象，必须实现 **`Serializable`** 接口。

3、注意：通过源代码发现，**Serializable**接口只是一个 **`标志接口`**：

```java
public interface Serializable {
}

```

这个接口当中什么代码都没有。

3.1Serializable接口起什么作用呢？
起到 标识 的作用，标志的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。
Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成一个序列化版本号。
4、序列化版本号有什么用呢？
区分两个类是否相同。

5、java语言中是采用什么机制来区分类的？
第一：首先通过 类名 进行比对，如果类名不一样，肯定不是同一个类。
第二：如果类名一样，再怎么进行类的区别？靠 序列化版本号 进行区分。
eg.
小明编写了一个类：com.baidu.java.bean.Student implements Serializable
小红编写了一个类：com.baidu.java.bean.Student implements Serializable
不同的人编写了同一个类，但“这两个类确实不是同一个类”。这个时候序列化版本就起上作用了。
对于java虚拟机来说，java虚拟机是可以区分开这两个类的，因为这两个类都实现了Serializable接口，都有默认的序列化版本号，他们的序列化版本号不一样。所以区分开了。（这是自动生成序列化版本号的好处）

6、这种自动生成序列化版本号有什么缺陷？
Java虚拟机看到Serializable接口之后，会自动生成一个序列化版本号。

这种自动生成的序列化版本号缺点是：一旦代码确定之后，不能进行后续的修改，因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java虚拟机会认为这是一个全新的类。（这样就不好了！）

7、最终结论：
凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。
这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。

8、怎样使某个属性不序列化

使用 **`transient`** 关键字

transient关键字表示游离的，**不参与序列化**。

```java
public user implements Serializable{
    private int no;
    private transient String name; // name不参与序列化操作！
}
```

15. ## java.io.ObjectOutputStream

ObjectOutputStream：序列化对象

```java
 public static void main(String[] args) throws Exception{
        // 创建java对象
        Student s = new Student(1111, "zhangsan");
        // 序列化
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("students"));

        // 序列化对象
        oos.writeObject(s);
        // 刷新
        oos.flush();
        // 关闭
        oos.close();
    }
```

```java
 public static void main(String[] args) throws Exception{
        List<User> userList = new ArrayList<>();
        userList.add(new User(1,"zhangsan"));
        userList.add(new User(2, "lisi"));
        userList.add(new User(3, "wangwu"));
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("users"));

        // 序列化一个集合，这个集合对象中放了很多其他对象。
        oos.writeObject(userList);

        oos.flush();
        oos.close();
    }

```

16. ## java.io.ObjectInputStream

ObjectInputStream：反序列化对象

```java
public static void main(String[] args) throws Exception{
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("students"));
        // 开始反序列化，读
        Object obj = ois.readObject();
        // 反序列化回来是一个学生对象，所以会调用学生对象的toString方法。
        System.out.println(obj);
        ois.close();
    }
```

```java
 public static void main(String[] args) throws Exception{
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("users"));
        //Object obj = ois.readObject();
        //System.out.println(obj instanceof List);//true
        List<User> userList = (List<User>)ois.readObject();
        for(User user : userList){
            System.out.println(user);
        }
        ois.close();
    }
```

17. **java.io.File**

File类和四大家族没有关系，所以File类不能完成文件的读和写。
File对象代表什么？
文件 和 目录路径名 的抽象表示形式。
eg.

C:\Drivers 这是一个File对象
C:\Drivers\Lan\Realtek\Readme.txt 也是File对象。
一个File对象有可能对应的是目录，也可能是文件。
File只是一个 路径名 的抽象表示形式。

```java
 public static void main(String[] args) {
        File f1 = new File("D:/IO/File1");
        if (!f1.exists()){
            try {
                f1.createNewFile();//创建文件
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        File f2 = new File("D:/IO/File2");
        if (!f2.exists()){
            f2.mkdir();//创建文件夹
        }

        File f3 = new File("D:/IO/File3/a/b/c/d/e/f/g/h/i");
        if (!f3.exists()){
            f3.mkdirs();//创建多重文件夹
        }

        File f5 = new File("D:\\IO\\FileDelete");
        f5.delete();

        File f4 = new File("D:\\Data\\新建文件夹");
        String s1 = f4.getName();//新建文件夹
        System.out.println(s1);

        String s2 = f4.getParent();//D:\Data
        System.out.println(s2);

        String s3 = f4.getPath();//D:\Data\新建文件夹
        System.out.println(s3);

        String s4 = f4.getAbsolutePath();//D:\Data\新建文件夹
        System.out.println(s4);

        File asf = f4.getAbsoluteFile();
        System.out.println(asf.getAbsolutePath());//D:\Data\新建文件夹

        File pf = f4.getParentFile();
        System.out.println(pf.getAbsolutePath());//D:\Data

        System.out.println(f4.isDirectory());//true

        System.out.println(f4.isFile());//false

        System.out.println(f4.isHidden());//false

        System.out.println(f4.isAbsolute());//true

        File f6 = new File("D:\\IO\\Day24.java");
        System.out.println(f6.length());//5743字节

        long lastModify = f6.lastModified();//最后修改时间
        Date d = new Date(lastModify);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date = sdf.format(d);
        System.out.println(date);//2021-05-03 22:55:06

        File f7 = new File("D:\\Data\\新建文件夹\\6、2020年最新 Java零基础入门到精通【完整资料】\\00_课程引入【马士兵说】");
        String[] strList = f7.list();
        for (String s : strList){
            System.out.println(s);
        }

        System.out.println("-----------------------------------------");
        File[] fileList = f7.listFiles();
        for (File f : fileList){
            //System.out.println(f.getPath());
            System.out.println(f.getAbsolutePath());
        }
    }
```

```java
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Objects;

class FileInputStreamTest01{
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("D:\\IO\\read.txt");

            int res = fis.read();//读到返回该字符ASCII码，没读到返回-1
            System.out.println(res);//97
            res = fis.read();
            System.out.println(res);//98
            res = fis.read();
            System.out.println(res);//99
            res = fis.read();
            System.out.println(res);//100
            res = fis.read();
            System.out.println(res);//-1
            res = fis.read();
            System.out.println(res);//-1
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileInputStreamTest02{
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("D:/IO/read.txt");

            int res = 0;
            while((res = fis.read()) != -1){
                System.out.println(res);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileInputStreamTest03{
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("D:/IO/read.txt");
            byte[] b = new byte[4];

            int readCount = fis.read(b);
            System.out.println(readCount);//4
            System.out.println(new String(b));//abcd
            readCount = fis.read(b);//2
            System.out.println(readCount);
            System.out.println(new String(b));//efcd  //数组不会清空，每一轮从0开始，读取存入
            readCount = fis.read(b);
            System.out.println(readCount);//-1

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileInputStreamTest04{
    public static void main(String[] args) {
        FileInputStream fis = null;

        try {
            fis = new FileInputStream("D:/IO/read.txt");
            byte[] b = new byte[4];

            int readCount = fis.read(b);
            System.out.println(new String(b, 0, readCount));//abcd
            readCount = fis.read(b);
            System.out.println(new String(b, 0, readCount));//ef

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileInputStreamTest05{
    public static void main(String[] args) {
        FileInputStream fis = null;

        try {
            fis = new FileInputStream("D:/IO/read.txt");
            byte[] b = new byte[30];//读中文时，数据需开大一点，否则会乱码（一个汉字等于两字节）
            int readCount = 0;

            while((readCount = fis.read(b)) != -1){
                System.out.println(new String(b, 0, readCount));
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileInputStreamTest06{
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("D:/IO/read.txt");

            /*int read = fis.read();
            System.out.println(fis.available());//5*/

            byte[] b = new byte[fis.available()];//不适合大数据量，因为内存中很难找到一块连续的空间
            fis.read(b);//一次读完
            System.out.println(new String(b));//abcdef

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileInputStreamTest06_1{
    public static void main(String[] args) {
        FileInputStream fis = null;

        try {
            fis = new FileInputStream("D:/IO/read.txt");

            int read = fis.read();
            System.out.println((char)read);//a
            fis.skip(2);//跳过两个字节
            read = fis.read();
            System.out.println((char)read);//d

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileOutputStreamTest01{
    public static void main(String[] args) {
        FileOutputStream fos = null;

        try {
            fos = new FileOutputStream("D:\\IO\\write1.txt");//没有文件会自动创建，每次自动清空文件内容，慎用！！！

            fos.write(65);
            fos.write(66);
            fos.write(67);
            fos.write(68);

            byte[] b = {97, 98, 99 , 100};
            fos.write(b);

            fos.write(b, 1, 2);

            fos.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileOutputStreamTest02{
    public static void main(String[] args) {
        FileOutputStream fos = null;

        try {
            fos = new FileOutputStream("D:/IO/write2.txt", true);

            byte[] b = {97, 98, 99 , 100};
            fos.write(b, 2, 1);
            String s = "我是中国人";
            byte[] bytes = s.getBytes();
            fos.write(bytes);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class Copy01{
    public static void main(String[] args) {
        FileInputStream fis = null;
        FileOutputStream fos = null;

        try {
            fis = new FileInputStream("D:\\Data\\新建文件夹\\6、2020年最新 Java零基础入门到精通【完整资料】\\00_课程引入【马士兵说】\\视频\\1.引入_授课说明【   www.52downloadcn】.mp4");
            fos = new FileOutputStream("D:/IO/授课说明.mp4");
            byte[] b = new byte[1024 * 1024];//1MB
            int readCount = 0;

            //一边读一边写
            while ((readCount = fis.read(b)) != -1){
                fos.write(b, 0 , readCount);
            }
            fos.flush();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileReaderTest01{
    public static void main(String[] args) {
        FileReader in = null;

        try {
            in = new FileReader("D:\\IO\\read.txt");
            int readCount = 0;
            while ((readCount = in.read()) != -1){
                System.out.print((char)readCount);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileReaderTest02{
    public static void main(String[] args) {
        FileReader reader = null;

        try {
            reader = new FileReader("D:\\IO\\read.txt");
            char[] c = new char[4];
            int readCount = 0;
            while ((readCount = reader.read(c)) != -1){
                System.out.println(new String(c, 0, readCount));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class FileWriterTest{
    public static void main(String[] args) {
        FileWriter writer = null;

        try {
            writer = new FileWriter("D:/IO/writer3.txt", true);
            writer.write(87);
            writer.write("我是中国人");
            char[] c = {'\n', '你', '好', '中', '国'};
            writer.write(c);
            writer.write(c, 1, 2);
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class Copy02{
    public static void main(String[] args) {
        FileReader reader = null;
        FileWriter writer = null;

        try {
            reader = new FileReader("D:\\IDEA_WorkPlace\\java_WorkPlace\\TestProject\\Practice\\src\\practice\\Day24.java");
            writer = new FileWriter("D:/IO/Day24.java");
            char[] c = new char[1024 * 512];//1MB
            int readCount = 0;
            //边读边写
            while((readCount = reader.read(c)) != -1){
                writer.write(c, 0, readCount);
            }
            writer.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class BufferedReaderTest01{
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            FileReader fr = new FileReader("D:\\IO\\Day24.java");//节点流
            reader = new BufferedReader(fr);//包装流
            int readCount = 0;
            while ((readCount = reader.read()) != -1){//单个取
                System.out.print((char)readCount);//加ln排版有问题
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

class BufferedReaderTest02{
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader("D:\\IO\\Day24.java"));
            int readCount = 0;
            char[] c = new char[10];//字节数组
            while ((readCount = reader.read(c)) != -1){
                System.out.print(new String(c, 0, readCount));//加ln排版有问题
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

class BufferedReaderTest03{
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader("D:/IO/Day24.java"));
            String res =  "";
            while((res = reader.readLine()) != null){
                System.out.println(res);//readLine()读不到换行符，需要手动换行
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

class BufferWriterTest01{
    public static void main(String[] args) {
        BufferedWriter writer = null;
        try {
            FileWriter fw = new FileWriter("D:/IO/writer4.txt", true);
            writer = new BufferedWriter(fw);
            writer.write(97);
            writer.write("我是中国人");
            writer.write(new char[]{'福', '建', '人'});
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class BufferedReaderTest04{
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            FileInputStream fis = new FileInputStream("D:/IO/Day24.java");
            InputStreamReader isr = new InputStreamReader(fis);//字节流转字符流
            reader = new BufferedReader(isr);

            String res =  "";
            while((res = reader.readLine()) != null){
                System.out.println(res);//readLine()读不到换行符，需要手动换行
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class BufferWriterTest02{
    public static void main(String[] args) {
        BufferedWriter writer = null;
        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("D:/IO/writer5.txt", true)));//三步合一
            writer.write(97);
            writer.write("我是中国人");
            writer.write(new char[]{'福', '建', '人'});
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class DataOutputStreamTest01{
    public static void main(String[] args) {
        DataOutputStream dos = null;

        try {
            dos = new DataOutputStream(new FileOutputStream("D:/IO/writer6.txt", true));
            byte b = 1;
            short s = 2;
            int i = 3;
            long l = 4L;
            float f = 3.99F;
            double d = 3.14;
            boolean flag = true;
            char sex = '男';
            dos.writeByte(b);
            dos.writeShort(s);
            dos.writeInt(i);
            dos.writeLong(l);
            dos.writeFloat(f);
            dos.writeDouble(d);
            dos.writeBoolean(flag);
            dos.writeChar(sex);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (dos != null) {
                try {
                    dos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class DataInputStreamTest01{
    public static void main(String[] args) {
        DataInputStream dis = null;

        try {
            dis = new DataInputStream(new FileInputStream("D:/IO/writer6.txt"));
            System.out.println(dis.readByte());
            System.out.println(dis.readShort());
            System.out.println(dis.readInt());
            System.out.println(dis.readLong());
            System.out.println(dis.readFloat());
            System.out.println(dis.readDouble());
            System.out.println(dis.readBoolean());
            System.out.println(dis.readChar());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (dis != null) {
                try {
                    dis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class PrintStreamTest01{
    public static void main(String[] args) {

        try {
            //1.改变流的输出方向
            PrintStream ps = new PrintStream(new FileOutputStream("D:/IO/writer7.txt", true));
            //PrintStream ps = new PrintStream("D:/IO/writer7.txt");//会清空内容
            System.setOut(ps);

            System.out.println("hello world");
            System.out.println("你好世界");
            System.out.println("hi world");

            //标准输出流不需要关闭
            //ps.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }
}

class Logger{
    public static void log(String msg){
        try {
            System.setOut(new PrintStream(new FileOutputStream("D:/IO/Log.txt", true)));
            Date d = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String date = sdf.format(d);
            System.out.println(date + ":" + msg);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class LoggerTest{
    public static void main(String[] args) {
        Logger.log("用户登入");
        Logger.log("用户备份数据库记录");
        Logger.log("用户调用GC垃圾回收器");
        Logger.log("用户删除数据库信息");
        Logger.log("用户退出");
    }
}

class Logger02{
    public static void log(String msg){
        BufferedWriter writer = null;

        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("D:/IO/Log2.txt", true)));
            Date d = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String date = sdf.format(d);
            writer.write(date + ":" + msg + '\n');
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class LoggerTest02{
    public static void main(String[] args) {
        Logger02.log("用户登入");
        Logger02.log("用户备份数据库记录");
        Logger02.log("用户调用GC垃圾回收器");
        Logger02.log("用户删除数据库信息");
        Logger02.log("用户退出");
    }
}

class FileTest01{
    public static void main(String[] args) {
        File f1 = new File("D:/IO/File1");
        if (!f1.exists()){
            try {
                f1.createNewFile();//创建文件
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        File f2 = new File("D:/IO/File2");
        if (!f2.exists()){
            f2.mkdir();//创建文件夹
        }

        File f3 = new File("D:/IO/File3/a/b/c/d/e/f/g/h/i");
        if (!f3.exists()){
            f3.mkdirs();//创建多重文件夹
        }

        File f5 = new File("D:\\IO\\FileDelete");
        f5.delete();

        File f4 = new File("D:\\Data\\新建文件夹");
        String s1 = f4.getName();//新建文件夹
        System.out.println(s1);

        String s2 = f4.getParent();//D:\Data
        System.out.println(s2);

        String s3 = f4.getPath();//D:\Data\新建文件夹
        System.out.println(s3);

        String s4 = f4.getAbsolutePath();//D:\Data\新建文件夹
        System.out.println(s4);

        File asf = f4.getAbsoluteFile();
        System.out.println(asf.getAbsolutePath());//D:\Data\新建文件夹

        File pf = f4.getParentFile();
        System.out.println(pf.getAbsolutePath());//D:\Data

        System.out.println(f4.isDirectory());//true

        System.out.println(f4.isFile());//false

        System.out.println(f4.isHidden());//false

        System.out.println(f4.isAbsolute());//true

        File f6 = new File("D:\\IO\\Day24.java");
        System.out.println(f6.length());//5743字节

        long lastModify = f6.lastModified();//最后修改时间
        Date d = new Date(lastModify);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date = sdf.format(d);
        System.out.println(date);//2021-05-03 22:55:06

        File f7 = new File("D:\\Data\\新建文件夹\\6、2020年最新 Java零基础入门到精通【完整资料】\\00_课程引入【马士兵说】");
        String[] strList = f7.list();
        for (String s : strList){
            System.out.println(s);
        }

        System.out.println("-----------------------------------------");
        File[] fileList = f7.listFiles();
        for (File f : fileList){
            //System.out.println(f.getPath());
            System.out.println(f.getAbsolutePath());
        }
    }
}

class student implements  Serializable{
    //鼠标放student上 alt+回车 快速生成序列化版本号
    private static final long serialVersionUID = -2060760799511982385L;
}

class ObjectOutputStreamTest01{
    public static void main(String[] args) {
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream("D:/IO/writer8.txt"));
            oos.writeObject(new String("hello world"));
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (oos != null) {
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}


class ObjectInputStreamTest01{
    public static void main(String[] args) {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("D:/IO/writer8.txt"));
            Object o = ois.readObject();
            if (o instanceof String){
                String s = (String)o;
                System.out.println(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (ois != null) {
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class HumanBeing implements Serializable {
    private static final long serialVersionUID = 7685244183746572805L;

    private int age;
    private String name;
    private double height;
    private transient float weight;//不参与序列化，反序列化出来为默认值

    public HumanBeing() {
    }

    public HumanBeing(int age, String name, double height, float weight) {
        this.age = age;
        this.name = name;
        this.height = height;
        this.weight = weight;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getHeight() {
        return height;
    }

    public void setHeight(double height) {
        this.height = height;
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", height=" + height +
                ", weight=" + weight +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        HumanBeing that = (HumanBeing) o;
        return age == that.age &&
                Double.compare(that.height, height) == 0 &&
                Objects.equals(name, that.name);
    }
}

class ObjectOutputStreamTest02{
    public static void main(String[] args) {
        ObjectOutputStream oos = null;

        try {
            oos = new ObjectOutputStream(new FileOutputStream("D:/IO/writer9.txt"));
            HumanBeing zhangsan = new HumanBeing(18, "zhangsan", 1.78, 150.0F);
            HumanBeing lisi = new HumanBeing(18, "lisi", 1.78, 123F);
            oos.writeObject(zhangsan);
            oos.writeObject(lisi);
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally{
            if (oos != null) {
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class ObjectInputStreamTest02{
    public static void main(String[] args) {
        ObjectInputStream ois = null;

        try {
            ois = new ObjectInputStream(new FileInputStream("D:/IO/writer9.txt"));
            Object o = ois.readObject();
            if (o instanceof HumanBeing){
                HumanBeing humanbeing = (HumanBeing) o;
                System.out.println(humanbeing);
            }
            o = ois.readObject();
            if (o instanceof HumanBeing){
                HumanBeing humanbeing = (HumanBeing) o;
                System.out.println(humanbeing);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally{
            if (ois != null) {
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class ObjectOutputStreamTest03{
    public static void main(String[] args) {
        ObjectOutputStream oos = null;

        try {
            oos = new ObjectOutputStream(new FileOutputStream("D:/IO/writer10.txt"));
            List<HumanBeing> list = new ArrayList<HumanBeing>();
            list.add(new HumanBeing(18, "zhangsan", 178, 190));
            list.add(new HumanBeing(18, "lisi", 128, 155));
            list.add(new HumanBeing(18, "wangwu", 118, 132));
            list.add(new HumanBeing(18, "zhaoliu", 158, 112));

            oos.writeObject(list);
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (oos != null) {
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class ObjectInputStreamTest03{
    public static void main(String[] args) {
        ObjectInputStream ois = null;

        try {
            ois = new ObjectInputStream(new FileInputStream("D:/IO/writer10.txt"));
            Object o = ois.readObject();
            if (o instanceof List){
                ArrayList list = (ArrayList) o;
                for(int i = 0; i < list.size(); i++){
                    System.out.println(list.get(i));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (ois != null) {
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}


```

